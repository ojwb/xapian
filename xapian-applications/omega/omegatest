#!/bin/sh
# omegatest: Test omega CGI
#
# Copyright (C) 2015,2016,2017,2018 Olly Betts
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
# USA
set -e

: ${OMEGA=./omega}
: ${SCRIPTINDEX=./scriptindex}

# Suppress HTTP Content-Type header.
SERVER_PROTOCOL=INCLUDED
export SERVER_PROTOCOL

# Set up an empty database.
TEST_DB=test-db
rm -rf "$TEST_DB"
echo 'inmemory' > "$TEST_DB"

# Simple template which just shows the parsed query.
TEST_TEMPLATE=test-template
printf '$querydescription' > "$TEST_TEMPLATE"

TEST_INDEXSCRIPT=test-indexscript

OMEGA_CONFIG_FILE=test-omega.conf
export OMEGA_CONFIG_FILE
cat > "$OMEGA_CONFIG_FILE" <<__END__
database_dir .
template_dir .
log_dir tmplog
default_template $TEST_TEMPLATE
default_db $TEST_DB
__END__

failed=0

testcase() {
    expected=$1
    shift
    # If there are no positional parameters, pass one as otherwise omega will
    # wait for parameters on stdin.
    [ "$#" != 0 ] || { set x dummy; shift; }
    output=`$FAKETIME ${FAKE_NOW+"$FAKE_NOW"} "$OMEGA" "$@"`
    if [ "$output" != "$expected" ] ; then
	echo "$OMEGA $@:"
	printf '%s\n' "  expected: «$expected»"
	printf '%s\n' "  received: «$output»"
	failed=`expr $failed + 1`
    fi
}

qtestcase() {
    expected="Query($1)"
    shift
    testcase "$expected" "$@"
}

FAKETIME=
unset FAKE_NOW

# Feature tests for boolprefix and prefix maps.
printf '$set{stemmer,}$setmap{boolprefix,lang,L,host,H}$setmap{prefix,,XDEFAULT}$querydescription' > "$TEST_TEMPLATE"
qtestcase '((XDEFAULTfoo@1 AND XDEFAULTbar@2) FILTER (Hexample.org AND Lzh))' P='host:example.org foo bar lang:zh'

# Feature tests for $cond.
printf '$cond{$cgi{one},1,$cgi{two},2,$cgi{three},3}' > "$TEST_TEMPLATE"
testcase '1' one=true
testcase '2' two=true
testcase '3' three=true
testcase '' nothing=true
testcase '1' one=true two=true three=true
testcase '2' two=true three=true
printf '$cond{$cgi{one},1,$cgi{two},2,$cgi{alt}}' > "$TEST_TEMPLATE"
testcase '1' one=true
testcase '2' two=true
testcase 'none' alt=none
# Check evaluation is lazy.
printf '$cond{$cgi{one},$seterror{err1},$cgi{two},2,$cgi{alt}}$error' > "$TEST_TEMPLATE"
testcase 'err1' one=true
testcase '2' two=true
testcase 'none' alt=none
printf '$cond{$cgi{one},1,$cgi{two},$seterror{err2},$cgi{alt}}$error' > "$TEST_TEMPLATE"
testcase '1' one=true
testcase 'err2' two=true
testcase 'none' alt=none
printf '$cond{$cgi{one},1,$cgi{two},2,$seterror{erralt}}$error' > "$TEST_TEMPLATE"
testcase '1' one=true
testcase '2' two=true
testcase 'erralt' alt=none

# Feature tests for $switch.
printf '$switch{$cgi{x},1,one,2,two}' > "$TEST_TEMPLATE"
testcase 'one' x=1
testcase 'two' x=2
testcase '' x=3
printf '$switch{$cgi{x},1,one,2,two,default}' > "$TEST_TEMPLATE"
testcase 'one' x=1
testcase 'two' x=2
testcase 'default' x=3
# Check evaluation is lazy.
printf '$switch{$cgi{x},1,$seterror{err1},2,two}$error' > "$TEST_TEMPLATE"
testcase 'err1' x=1
testcase 'two' x=2
testcase '' x=3
printf '$switch{$cgi{x},1,one,2,$seterror{err2},default}$error' > "$TEST_TEMPLATE"
testcase 'one' x=1
testcase 'err2' x=2
testcase 'default' x=3
printf '$switch{$cgi{x},1,one,2,two,$seterror{errdefault}}$error' > "$TEST_TEMPLATE"
testcase 'one' x=1
testcase 'two' x=2
testcase 'errdefault' x=3

# Feature tests for $map.
printf '$list{$map{$split{-,$cgi{a}},$list{$map{$split{,$cgi{b}},$_},-}},|}' > "$TEST_TEMPLATE"
testcase '1-2-3|1-2-3' P=text a=ab-cd b=123
printf '$list{$map{$split{-,$cgi{a}},$set{__,$_}$list{$map{$split{,$cgi{b}},$opt{__}$_},-}},|}' > "$TEST_TEMPLATE"
testcase 'a1-a2-a3|b1-b2-b3' P=text a=a-b b=123
printf '$list{$map{$split{-,$cgi{a}},$list{$map{$split{$_,$cgi{b}},$_},-}},|}' > "$TEST_TEMPLATE"
testcase '1-2,3|1:2-3' P=text a=':-,' b='1:2,3'
# Check that the outer $_ is restored after the inner $map.
printf '$list{$map{$split{-,$cgi{a}},$list{$map{$split{,$cgi{b}},$_},-}$_},|}' > "$TEST_TEMPLATE"
testcase '1-2-3a|1-2-3b' P=text a='a-b' b='123'

# Feature tests for $terms.
printf 'text : index\nhost : boolean=H\nfoo : boolean=XFOO' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null <<'END'
text=This is some text.
host=example.org
foo=bar
END
printf '$hitlist{$list{$if{$eq{$cgi{prefix},null},$terms,$terms{$cgi{prefix}}},|}}' > "$TEST_TEMPLATE"
testcase 'Ztext' P=text B=Hexample.org B=Hexample.com prefix=null
testcase 'Hexample.org|Ztext' P=text B=Hexample.org B=Hexample.com prefix=
testcase 'Hexample.org' P=text B=Hexample.org B=Hexample.com prefix=H
testcase 'Ztext' P=text B=Hexample.org B=Hexample.com prefix=Z
testcase '' P=text B=Hexample.org B=Hexample.com prefix=E

printf '$msizelower $msize $msizeupper $msizeexact' > "$TEST_TEMPLATE"
testcase '1 1 1 true' P=this
testcase '1 1 1 true' P='Some text'
testcase '0 0 0 true' P=potato

printf '$set{weighting,coord}$hitlist{$weight.}' > "$TEST_TEMPLATE"
testcase '' P=aardvark
testcase '1.000000.' P=texting
testcase '' P='texting while driving'
testcase '' P='texting while driving' DEFAULTOP=AND
testcase '1.000000.' P='texting while driving' DEFAULTOP=OR
testcase '2.000000.' P='Some text'
# "this" and "is" are stopwords.
testcase '2.000000.' P='This is some text'
testcase '4.000000.' P='"This" "is" some text'
testcase '4.000000.' P='+This +is some text'
testcase '4.000000.' P='"This is some text"'

printf '$set{weightingpurefilter,coord}$hitlist{$weight.}' > "$TEST_TEMPLATE"
testcase '' B=XFOOfoo
testcase '1.000000.' B=Hexample.org
testcase '' B=Hexample.org B=XFOOfoo
testcase '1.000000.' B=Hexample.org B=Hexample.net
testcase '2.000000.' B=Hexample.org B=XFOObar
testcase '3.000000.' B=Hexample.org B=XFOObar B=XFOObar

printf '$filters' > "$TEST_TEMPLATE"
testcase 'Hexample.net~Hexample.org~.~~' B=Hexample.org B=Hexample.net
testcase '!Gmisc.test~.~~' N=Gmisc.test
testcase 'Hexample.net~Hexample.org~!Gmisc.test~.~~' B=Hexample.org B=Hexample.net N=Gmisc.test
testcase '.20040612~~~1~' DATEVALUE=1 START=20040612
testcase '.20040612~~~1~2' DATEVALUE=1 START=20040612 COLLAPSE=2
testcase '.20040612~~30~2' START=20040612 SPAN=30 COLLAPSE=2
testcase '.20040612~20160412~' START=20040612 END=20160412
testcase '.~~~2' COLLAPSE=2
testcase '.~~'
testcase '.~~1' SORT=1
testcase '.~~1f' SORT=+1
testcase '.~~1' SORT=-1
testcase '.~~1-2+3-27' SORT=+1-2+03,-27
testcase '.~~' SORTREVERSE=1
testcase '.~~1f' SORT=1 SORTREVERSE=1
testcase '.~~1' SORT=+1 SORTREVERSE=1
testcase '.~~1f' SORT=-1 SORTREVERSE=1
testcase '.~~1-2+3-27f' SORT=+1-2+03,-27 SORTREVERSE=1
testcase '.~~' SORTAFTER=1
testcase '.~~1R' SORT=1 SORTAFTER=1
testcase '.~~1F' SORT=+1 SORTAFTER=1
testcase '.~~1R' SORT=-1 SORTAFTER=1
testcase '.~~1-2+3-27R' SORT=+1-2+03,-27 SORTAFTER=1
testcase '.~~' SORTREVERSE=1 SORTAFTER=1
testcase '.~~1F' SORT=1 SORTREVERSE=1 SORTAFTER=1
testcase '.~~1R' SORT=+1 SORTREVERSE=1 SORTAFTER=1
testcase '.~~1F' SORT=-1 SORTREVERSE=1 SORTAFTER=1
testcase '.~~1-2+3-27F' SORT=+1-2+03,-27 SORTREVERSE=1 SORTAFTER=1
testcase '.~~X' DOCIDORDER=A # Buggy, but kept for compatibility.
testcase '.~~D' DOCIDORDER=D
testcase '.~~' DOCIDORDER=X # Buggy, but kept for compatibility.
testcase '.~~' DOCIDORDER=x # Buggy, but kept for compatibility.

tab=`printf '\t'`
printf '$cgi{AZ}|$cgi{AZ B}|$cgi{AZ.x}|$cgi{AZ.y}|$cgi{[}|$cgi{#}' > "$TEST_TEMPLATE"
testcase 'AZ|||||' AZ.x=3 AZ.y=4
testcase 'B|||||' 'AZ B.x=5' 'AZ B.y=12'
testcase 'B|||||' "AZ${tab}B.x=5" "AZ${tab}B.y=12"
testcase '||||2 ]|' '[ 2 ].x=123'
testcase '||||2 ]|' "[${tab}2 ].x=123"
testcase "||||2${tab}]|" "[ 2${tab}].x=123"
testcase "||||2${tab}]|" "[${tab}2${tab}].x=123"
testcase '|||||12' '12.x=37'
testcase 'DE|||||' 'AZ BC=DE'
testcase 'DE|||||' 'AZ B C=DE'
testcase 'DE|||||' "AZ${tab}BC=DE"
testcase 'DE|||||' "AZ B${tab}C=DE"
testcase 'DE|||||' "AZ${tab}B C=DE"
testcase 'DE|||||' "AZ${tab}B${tab}C=DE"

printf '$cgi{Search}|$cgi{Type}|$cgi{Search Type}' > "$TEST_TEMPLATE"
testcase 'Discover-List||' 'Search Type=Discover-List'

printf '$cgiparams' > "$TEST_TEMPLATE"
# We can't test the "no cgi parameters" case via testcase, as it passes a
# "dummy" parameter if there aren't any real ones.
#testcase ""
testcase "" =1
testcase "ABC" ABC=1
testcase "ABC" ABC=1 ABC=2
testcase "A${tab}AZ${tab}Z" A=1 A=2 A=3 AZ=1 AZ=2 Z=xxx
testcase "${tab}abc" =1 abc=1
testcase "${tab}abc${tab}def" =1 abc=1 def=7

# Feature tests for $highlight{}.
printf '$highlight{$cgi{text},$cgi{list}}' > "$TEST_TEMPLATE"
testcase 'A <b style="color:black;background-color:#ffff66">list</b> of <b style="color:black;background-color:#99ff99">words</b>' list="list${tab}words" text="A list of words"

printf '$highlight{$cgi{text},$cgi{list},$cgi{open}}' > "$TEST_TEMPLATE"
testcase 'A list of <b>words</b>' list="words" text="A list of words" open="<b>"
testcase 'A list of <span>words</span>' list="words" text="A list of words" open="<span>"

printf '$highlight{$cgi{text},$cgi{list},$cgi{open},$cgi{close}}' > "$TEST_TEMPLATE"
testcase 'A list of <b>words</b>' list="words" text="A list of words" open="<b>" close="</b>"
testcase 'A *list* of *words*' list="words${tab}list" text="A list of words" open="*" close="*"

# Test setting seterror and mset size, should not run the query after setting error.
printf '$if{$cgi{ERR},$seterror{$cgi{ERR}}}$msize$if{$error,!$error!}' > "$TEST_TEMPLATE"
testcase '1' P=text
testcase '0!boo!' P=text ERR=boo

# Test arguments inside seterror are evaluated
printf '$set{error,sample error}$seterror{$opt{error}}$msize$if{$error,!$error!}' > "$TEST_TEMPLATE"
testcase '0!sample error!' P=text

# Test error message doesn't get sent through HTML entity encoding.
printf '$seterror{{ "error": true, "error_message": "Parameter cannot be > 9" }}$if{$error,$error}' > "$TEST_TEMPLATE"
testcase '{ "error": true, "error_message": "Parameter cannot be > 9" }' P=text

# Test msize when error set after running query, should not affect running of query.
printf '$last$if{$cgi{ERR},$seterror{$cgi{ERR}}}$msize$if{$error,!$error!}' > "$TEST_TEMPLATE"
testcase '11' P=text
testcase '11!boo!' P=text ERR=boo

# Feature tests for $hash{}
printf '$hash{$cgi{text},md5}' > "$TEST_TEMPLATE"
testcase '098f6bcd4621d373cade4e832627b4f6' text="test"
testcase 'b4c216e4da73d1d01277ef46d0514821' text="simple query"
testcase 'd41d8cd98f00b204e9800998ecf8427e' text=""
testcase '3302c94d3500c3f695b7e09b7acd420d' text=" test "

# Regression test - original implementation truncated data at first zero byte.
printf '$hash{$cgi{text}$chr{0},md5}' > "$TEST_TEMPLATE"
testcase 'e2a3e68d23ce348b8f68b3079de3d4c9' text="test"

printf '$hash{$cgi{text},invalidhash}' > "$TEST_TEMPLATE"
testcase 'Exception: Unknown hash function: invalidhash' text="test"

# Feature tests for $uniq and $unique{}.
printf '$list{$uniq{$split{$cgi{text}}},:}|$list{$unique{$split{$cgi{text}}},:}' > "$TEST_TEMPLATE"
testcase '|' text=''
testcase 'foo|foo' text='foo'
testcase 'apple:banana:cherry|apple:banana:cherry' text='apple apple banana banana banana cherry'
testcase 'a:b:r:a:c:a:d:a:b:r:a|a:b:r:c:d' text='a b r a c a d a b r a'
testcase 'x:y:z:y|x:y:z' text='x y z z y'

# Regression test - $map with one argument wasn't rejected cleanly.
printf '$map{foo}' > "$TEST_TEMPLATE"
testcase 'Exception: too few arguments to $map'

# Feature tests for split command scriptindex.
printf 'STATUS : field split=| field=SPLITSTATUS\nSTATUS : field=x' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null <<'END'
STATUS=PENDING|REVIEW
END
printf '$field{STATUS,1}/$field{x,1}/$list{$field{SPLITSTATUS,1},$.}' > "$TEST_TEMPLATE"
testcase 'PENDING|REVIEW/PENDING|REVIEW/PENDING,REVIEW' P=text

# Feature tests for split dedup command scriptindex.
printf 'STATUS : field split=|,dedup field=SPLITSTATUS\n' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null <<'END'
STATUS=REVIEW|PENDING|PENDING|REVIEW
END
printf '$field{STATUS,1}/$list{$field{SPLITSTATUS,1},$.}' > "$TEST_TEMPLATE"
testcase 'REVIEW|PENDING|PENDING|REVIEW/REVIEW,PENDING' P=text

# Feature tests for split sort command scriptindex.
printf 'STATUS : field split=|,sort field=SPLITSTATUS\n' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null <<'END'
STATUS=REVIEW|PENDING|PENDING|REVIEW
END
printf '$field{STATUS,1}/$list{$field{SPLITSTATUS,1},$.}' > "$TEST_TEMPLATE"
testcase 'REVIEW|PENDING|PENDING|REVIEW/PENDING,PENDING,REVIEW,REVIEW' P=text

# Feature tests for split none command scriptindex.
printf 'STATUS : field split=|,none field=SPLITSTATUS\n' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null <<'END'
STATUS=REVIEW|PENDING|PENDING|REVIEW
END
printf '$field{STATUS,1}/$list{$field{SPLITSTATUS,1},$.}' > "$TEST_TEMPLATE"
testcase 'REVIEW|PENDING|PENDING|REVIEW/REVIEW,PENDING,PENDING,REVIEW' P=text

# Feature tests for split command scriptindex without operation argument.
printf 'STATUS : field split=| field=SPLITSTATUS\n' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null <<'END'
STATUS=PENDING|REVIEW|PENDING|REVIEW
END
printf '$field{STATUS,1}/$list{$field{SPLITSTATUS,1},$.}' > "$TEST_TEMPLATE"
testcase 'PENDING|REVIEW|PENDING|REVIEW/PENDING,REVIEW,PENDING,REVIEW' P=text

# Feature test for multi-character split delimiter.
printf 'STATUS : field split=$. field=SPLITSTATUS\n' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null <<'END'
STATUS=PENDING$.$.REVIEW,PENDING$.REVIEW
END
printf '$field{STATUS,1}/$list{$field{SPLITSTATUS,1},|}' > "$TEST_TEMPLATE"
testcase 'PENDING$.$.REVIEW,PENDING$.REVIEW/PENDING|REVIEW,PENDING|REVIEW' P=text

# Feature test for multi-character split delimiter with potential overlap.
printf 'STATUS : field split=:: field=SPLITSTATUS\n' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null <<'END'
STATUS=::Foo::::Bar:Baz:::Hello::
END
printf '$field{STATUS,1}/$list{$field{SPLITSTATUS,1},|}' > "$TEST_TEMPLATE"
testcase '::Foo::::Bar:Baz:::Hello::/Foo|Bar:Baz|:Hello' P=text

# Feature tests for split command with "," delimiter passed , with double quotes.
printf 'STATUS : field split="," field=SPLITSTATUS\n' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null <<'END'
STATUS=PENDING,REVIEW,PENDING,REVIEW
END
printf '$field{STATUS,1}/$list{$field{SPLITSTATUS,1},|}' > "$TEST_TEMPLATE"
testcase 'PENDING,REVIEW,PENDING,REVIEW/PENDING|REVIEW|PENDING|REVIEW' P=text

# Feature test for nested split command.
printf 'in : split=; field=one lower split="," field=two\nin : field' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null <<'END'
in=a,b,c;10,21,32;XY,YZ
END
printf '$field{in,1}/$list{$field{one,1},|}/$list{$field{two,1},|}' > "$TEST_TEMPLATE"
testcase 'a,b,c;10,21,32;XY,YZ/a,b,c|10,21,32|XY,YZ/a|b|c|10|21|32|xy|yz' P=text

# Feature tests for scriptindex hextobin action.
printf 'hex : hextobin value=0' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null <<'END'
hex=

hex=41

hex=54657374

hex=4b696C6c
END
printf '$list{$map{$split{$cgi{DOCIDS}},$value{0,$_}},|}' > "$TEST_TEMPLATE"
testcase '|A|Test|Kill' DOCIDS='1 2 3 4'

# Feature test error cases for scriptindex hextobin action.
rm -rf "$TEST_DB"
echo hex=7g |\
    $SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" 2>&1 > /dev/null |\
    grep -q ":1: error: hextobin: input must be all hex digits" ||\
    { echo "scriptindex hextobin didn't give error for bad hex digit";\
      failed=`expr $failed + 1`; }
echo hex=404 |\
    $SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" 2>&1 > /dev/null |\
    grep -q ":1: error: hextobin: input must have even length" ||\
    { echo "scriptindex hextobin didn't give error for odd length hex string";\
      failed=`expr $failed + 1`; }
testcase '7g|404' DOCIDS='1 2'

# Test useless action warnings.
printf 'foo : index weight=2' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
if $SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" < /dev/null 2>&1 \
    | grep -q ":1:13: warning: Index action 'weight' has no effect" ; then
    : # OK
else
    echo "scriptindex didn't give expected warning for useless 'weight' action"
    failed=`expr $failed + 1`
fi
printf 'foo : weight=2 weight=3 index' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
if $SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" < /dev/null 2>&1 \
    | grep -q ":1:7: warning: Index action 'weight' has no effect" ; then
    : # OK
else
    echo "scriptindex didn't give expected warning for useless 'weight' action"
    failed=`expr $failed + 1`
fi
printf 'foo : index lower' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
if $SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" < /dev/null 2>&1 \
    | grep -q ":1:13: warning: Index action 'lower' has no effect" ; then
    : # OK
else
    echo "scriptindex didn't give expected warning for useless 'lower' action"
    failed=`expr $failed + 1`
fi

# Test bad fieldname errors.
printf 'foo *bar : index' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
rc=0
out=`$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" < /dev/null 2>&1` || rc=$?
if [ $rc -eq 0 ] ; then
    echo "scriptindex didn't exit with non-zero return code on bad fieldname"
    failed=`expr $failed + 1`
elif printf '%s' "$out" \
    | grep -q ":1:5: error: field name must start with alphanumeric" ; then
    : # OK
else
    echo "scriptindex didn't give expected error for a bad fieldname"
    failed=`expr $failed + 1`
fi
printf 'foo b!ar : index' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
rc=0
out=`$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" < /dev/null 2>&1` || rc=$?
if [ $rc -eq 0 ] ; then
    echo "scriptindex didn't exit with non-zero return code on bad fieldname"
    failed=`expr $failed + 1`
elif printf '%s' "$out" \
    | grep -q ":1:6: error: bad character '!' in fieldname" ; then
    : # OK
else
    echo "scriptindex didn't give expected error for a bad fieldname"
    failed=`expr $failed + 1`
fi

# Test unwanted action argument.
printf 'foo : spell=test index' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
rc=0
out=`$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" < /dev/null 2>&1` || rc=$?
if [ $rc -eq 0 ] ; then
    echo "scriptindex didn't exit with non-zero return code on unwanted action argument"
    failed=`expr $failed + 1`
elif printf '%s' "$out" \
    | grep -q ":1:12: error: Index action 'spell' doesn't take an argument" ; then
    : # OK
else
    echo "scriptindex didn't give expected error for unwanted action argument"
    failed=`expr $failed + 1`
fi

# Test missing closing quote.
printf 'foo : index="XFOO' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
rc=0
out=`$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" < /dev/null 2>&1` || rc=$?
if [ $rc -eq 0 ] ; then
    echo "scriptindex didn't exit with non-zero return code for missing closing quote"
    failed=`expr $failed + 1`
elif printf '%s' "$out" \
    | grep -q ":1:18: error: No closing quote" ; then
    : # OK
else
    echo "scriptindex didn't give expected error for missing closing quote"
    failed=`expr $failed + 1`
fi

# Feature tests for termprefix and unprefix.
printf '$termprefix{$cgi{B}}|$unprefix{$cgi{B}}' > "$TEST_TEMPLATE"
testcase '|' B=''
testcase '|something' B='something'
testcase '|42' B='42'
testcase '|3bad' B='3bad'
testcase '|&something' B='&something'
testcase '|:something' B=':something'
testcase 'H|example.org' B='Hexample.org'
testcase 'K|tag' B='Ktag'
testcase 'K|Capital' B='KCapital'
testcase 'K|:colon-tag' B='K:colon-tag'
testcase 'K|:Capital' B='K:Capital'
testcase 'XCOLOUR|red' B='XCOLOURred'
testcase 'XPUNC|:colon' B='XPUNC::colon'
testcase 'XPUNC|internal:colon' B='XPUNC:internal:colon'
testcase 'XPUNC|:Colon' B='XPUNC::Colon'
testcase 'XCASE|Upper' B='XCASE:Upper'
testcase 'XCASE|TITLE' B='XCASE:TITLE'
testcase 'XNUM|42' B='XNUM42'
testcase 'XNUM|3bad' B='XNUM3bad'

# Test to make sure out generate_sample function in sample.cc
# Doesn't run into negative memory access
printf '$truncate{$cgi{input},$cgi{maxlen},$cgi{ind},$cgi{ind2}}$seterror{$opt{error}}' > "$TEST_TEMPLATE"
testcase 'w...' input='wwwwww' maxlen=4 ind='...' ind2='...'
testcase '' input='s' maxlen=0 ind='...' ind2='...'

# Simple tests of $subdb and $subid.
rm -rf "$TEST_DB"
printf 'inmemory' > "$TEST_DB"
printf 'inmemory' > "${TEST_DB}2"
printf '$subdb{$cgi{ID}}|$subid{$cgi{ID}}' > "$TEST_TEMPLATE"
testcase "$TEST_DB|1" ID=1
testcase "$TEST_DB|1" ID=1 DB="$TEST_DB/${TEST_DB}2"
testcase "${TEST_DB}2|1" ID=2 DB="$TEST_DB/${TEST_DB}2"
testcase "${TEST_DB}|2" ID=3 DB="$TEST_DB/${TEST_DB}2"
rm -rf "${TEST_DB}2"

# Feature tests of scriptindex.
printf 'uuid : boolean=Q unique=Q\nguid : boolean=G unique=G' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
if $SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null < /dev/null 2>&1; then
    echo "scriptindex didn't reject 'unique' action being used more than once"
    failed=`expr $failed + 1`
fi

# Test we check for hash's argument being an integer (new in 1.4.6).
printf 'url : hash=37.3 boolean=Q unique=Q' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
if $SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" < /dev/null 2>&1 \
    | grep -q ":1:14: warning: Index action 'hash' takes an integer argument" ; then
    : # OK
else
    echo "scriptindex didn't reject 'hash' with a non-integer argument"
    failed=`expr $failed + 1`
fi

# Test we give a helpful error for an action with a digit in (regression
# test for fix in 1.4.6).
#
# This used to give the confusing:
# Unknown index action ''
printf 'url : index4' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
rc=0
out=`$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" < /dev/null 2>&1` || rc=$?
if [ $rc -eq 0 ] ; then
    echo "scriptindex didn't exit with non-zero return code for bad index action with a digit"
    failed=`expr $failed + 1`
elif printf '%s' "$out" \
    | grep -q ":1:7: error: Unknown index action 'index4'" ; then
    : # OK
else
    echo "scriptindex didn't give expected error for bad index action with a digit"
    failed=`expr $failed + 1`
fi

# Test we give a helpful error if an = sign is missed out before an optional
# numeric argument (regression test for fix in 1.4.6).
#
# This used to give the confusing:
# Unknown index action ''
printf 'url : hash 42' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
rc=0
out=`$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" < /dev/null 2>&1` || rc=$?
if [ $rc -eq 0 ] ; then
    echo "scriptindex didn't exit with non-zero return code for a missing equals sign"
    failed=`expr $failed + 1`
elif printf '%s' "$out" \
    | grep -q ":1:12: error: Unknown index action '42'" ; then
    : # OK
else
    echo "scriptindex didn't give expected error for a missing equals sign"
    failed=`expr $failed + 1`
fi

# Test we warn about spaces before and after '='.
#
# This has never been documented as supported, and was deprecated in 1.4.6
# because it resulted in this quietly using hash as the field name, which is
# probably not what was intended:
#
# url : field= hash boolean=Q unique=Q
printf 'url : field= hash boolean=Q unique=Q' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
if $SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" < /dev/null 2>&1 \
    | grep -q ":1:13: warning: putting spaces between '=' and the argument is deprecated" ; then
    : # OK
else
    echo "scriptindex didn't give expected warning for space after '='"
    failed=`expr $failed + 1`
fi
printf 'url : field =link' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
if $SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" < /dev/null 2>&1 \
    | grep -q ":1:12: warning: putting spaces between the action and '=' is deprecated" ; then
    : # OK
else
    echo "scriptindex didn't give expected warning for space before '='"
    failed=`expr $failed + 1`
fi

# Feature tests for datevalue command scriptindex.
printf '%s' 'DATE : field parsedate=%Y%m%d valuepacked=13\n' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null <<'END'
DATE=19891204
END
printf '$field{DATE,1}|$unpack{$value{13,1}}|$date{$unpack{$value{13,1}}}' > "$TEST_TEMPLATE"
testcase '19891204|628732800|1989-12-04' P=text

# Feature tests for datevalue command scriptindex where format contains space.
printf '%s' 'DATE : field parsedate="%Y%m%d %T" valuepacked=13\n' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null 2>&1 <<'END'
DATE=20161202 12:04:22.000000
END
printf '$unpack{$value{13,1}}|$date{$unpack{$value{13,1}}}' > "$TEST_TEMPLATE"
testcase '1480680262|2016-12-02' P=text

# Feature tests for quoted arguments.
printf 'DATE : field="  spaces  " date="yyyymmdd"\nTEXT: index\n' > "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null <<'END'
DATE=19891204
TEXT=This is sample text.
NEXT=work
END
printf '$freq{D19891204}|$field{  spaces  ,1}' > "$TEST_TEMPLATE"
testcase '1|19891204' P=text
# Use $time to force the match to run.
printf '$if{$time,$freq{D19891204}}|$field{  spaces  ,1}' > "$TEST_TEMPLATE"
testcase '1|19891204' P=

echo ZZZ

# Feature tests for escaping in quoted arguments.
printf 'esc : field="\\tesca\\x70e,test\\\\\\""\n' > "$TEST_INDEXSCRIPT"
cat -vet "$TEST_INDEXSCRIPT"
rm -rf "$TEST_DB"
$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" > /dev/null <<'END'
esc=test
END
printf '$field{$chr{9}escape$.test\",1}' > "$TEST_TEMPLATE"
echo aaa
testcase 'test' P=
echo AAA
# Ensure the location of the problem is always in the same column so we can
# test against a fixed error message including line and column.
for badesc in \
    '"xx\\' \
    '"xx\\q"' \
    '"\\x"' \
    '"\\x1"' \
    '"\\xg"' \
    '"\\x1g"' \
    '"\\x1g"' \
    ; do
    printf '%s' "x: split=$badesc" > "$TEST_INDEXSCRIPT"
    rm -rf "$TEST_DB"
    rc=0
    out=`$SCRIPTINDEX "$TEST_DB" "$TEST_INDEXSCRIPT" < /dev/null 2>&1` || rc=$?
    if [ $rc -eq 0 ] ; then
	echo "scriptindex didn't exit with non-zero return code on bad escaping"
	failed=`expr $failed + 1`
    elif printf '%s' "$out" \
	| grep -q ":1:14: error: Bad escaping in quoted action argument" ; then
	: # OK
    else
	echo "scriptindex didn't give expected error for bad escaping"
	printf '%s\n' "badesc=$badesc" "got: $out"
	failed=`expr $failed + 1`
    fi
done

rm "$OMEGA_CONFIG_FILE" "$TEST_INDEXSCRIPT" "$TEST_TEMPLATE"
rm -rf "$TEST_DB"
if [ "$failed" = 0 ] ; then
    exit 0
fi
echo "Failed $failed test(s)"
exit 1
